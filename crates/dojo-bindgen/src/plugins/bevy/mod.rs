use async_trait::async_trait;
use cainome::parser::tokens::{Composite, CompositeType, Function, FunctionOutputKind, Token};
use cainome::rs::{CairoEnum, CairoStruct};
use dojo_world::contracts::naming::{self, get_namespace_from_tag};
use proc_macro2::TokenStream as TokenStream2;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::error::BindgenResult;
use crate::plugins::BuiltinPlugin;
use crate::{DojoContract, DojoData, DojoModel};

#[derive(Debug)]
pub struct BevyPlugin {}

impl BevyPlugin {
    pub fn new() -> Self {
        Self {}
    }

    fn generate_bindgen_warning() -> String {
        format!(
            "// Generated by dojo-bindgen on {}. Do not modify this file manually.\n",
            chrono::Utc::now().to_rfc2822()
        )
    }

    fn generate_bevy_imports() -> String {
        "use bevy::prelude::*;\n".to_string()
    }

    fn handle_components(
        &self,
        model: &DojoModel,
        handled_tokens: &mut HashMap<String, Composite>,
    ) -> String {
        let mut out = String::new();

        out += BevyPlugin::generate_bindgen_warning().as_str();
        out += BevyPlugin::generate_bevy_imports().as_str();

        let tag = &model.tag;

        let mut token_stream: Vec<TokenStream2> = vec![];
        let derives = vec!["Debug".to_string(), "Component".to_string()];
        for token in &model.tokens.structs {
            let composite = token.to_composite().expect("composite expected");
            token_stream.push(CairoStruct::expand_decl(composite, &derives));
            token_stream.push(CairoStruct::expand_impl(composite));
        }

        for token in &model.tokens.enums {
            let composite = token.to_composite().expect("composite expected");
            token_stream.push(CairoEnum::expand_decl(composite, &derives));
            token_stream.push(CairoEnum::expand_impl(composite));
        }

        token_stream.iter().for_each(|ts| {
            out += &format!("{}", ts);
        });

        out
    }
}

#[async_trait]
impl BuiltinPlugin for BevyPlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut out: HashMap<PathBuf, Vec<u8>> = HashMap::new();
        let mut handled_tokens = HashMap::<String, Composite>::new();

        let imports_path = Path::new("components/mod.rs").to_owned();
        let mut mod_imports: Vec<String> = vec![];

        // Handle codegen for models
        for (name, model) in &data.models {
            let name = name.split('-').last().unwrap().to_lowercase();
            mod_imports.push(format!("pub mod {};", name));
            let models_path = Path::new(&format!("components/{}.rs", name)).to_owned();

            println!("Generating model: {}", name);
            let code = self.handle_components(model, &mut handled_tokens);

            out.insert(models_path, code.as_bytes().to_vec());
        }

        let import_code = format!("{}\n", mod_imports.join("\n"));
        out.insert(imports_path, import_code.as_bytes().to_vec());

        Ok(out)
    }
}
