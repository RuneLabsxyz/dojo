use crate::error::BindgenResult;
use crate::plugins::BuiltinPlugin;
use crate::{DojoData, DojoModel};
use async_trait::async_trait;
use cainome::rs::ExecutionVersion;
use chrono::{DateTime, Utc};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use syn::{File, Type};

#[derive(Debug)]
pub struct GodotPlugin {
    generated_time: DateTime<Utc>,
}

impl GodotPlugin {
    pub fn new() -> Self {
        Self { generated_time: Utc::now() }
    }

    fn get_header(&self) -> String {
        // NOTE: Procedural macros cannot insert comments.
        //  As this is meant to be read by a user, we hard-code it in the output.
        format!(
            "// Generated by dojo-bindgen on {}. Do not modify this file manually.\n",
            self.generated_time.to_rfc2822()
        )
    }

    fn get_imports(&self) -> TokenStream {
        quote! {
            use godot::prelude::*;
            use cainome::cairo_serde::ContractAddress;
            use dojo_types::schema::Struct as DojoStruct;
        }
    }

    fn handle_model(&self, name: &str, model: &DojoModel) -> TokenStream {
        let imports = self.get_imports();

        let name = name.split('-').last().unwrap().to_lowercase();

        let contents = cainome::rs::abi_to_tokenstream(&*name, &model.tokens, ExecutionVersion::V1);

        quote! {
            #imports

            #contents
        }
    }

    fn get_file(&self, stream: TokenStream) -> Vec<u8> {
        // TODO: This is not optimized, at all. We clone & resize vectors, but welp
        // TODO: Remove the unwrap

        let value: File = syn::parse2(stream).unwrap();
        let parsed_contents = prettyplease::unparse(&value);

        format!("{}{}", self.get_header(), parsed_contents).into_bytes()
    }
}

#[async_trait]
impl BuiltinPlugin for GodotPlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut imports = vec![];

        let mut files: HashMap<PathBuf, Vec<u8>> = HashMap::new();

        for (name, model) in &data.models {
            let name = name.split('-').last().unwrap().to_lowercase();
            imports.push(Ident::new(&*name, Span::call_site()));

            println!("Adding file {name}...");

            let path = Path::new(&format!("{}.rs", name)).to_owned();
            files.insert(path, self.get_file(self.handle_model(&*name, model)));

            println!("Added file! {name}");
        }

        let lib_contents = quote! {
            #( pub mod #imports; )*
        };

        println!("Finishing!!! {}", lib_contents);

        files.insert(Path::new("lib.rs").to_owned(), self.get_file(lib_contents));

        // TODO: Contracts?

        Ok(files)
    }
}
