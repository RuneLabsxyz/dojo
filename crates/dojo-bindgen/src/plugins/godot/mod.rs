use std::collections::HashMap;
use std::path::{Path, PathBuf};
use async_trait::async_trait;
use cainome::parser::tokens::Composite;
use cainome::rs::{CairoEnum, CairoStruct};
use cainome_parser::tokens::{Function, Token};
use cainome_rs::{CairoFunction, ExecutionVersion};
use chrono::{DateTime, Utc};
use proc_macro2::{Ident, Span, TokenStream};
use crate::{DojoData, DojoModel};
use crate::error::BindgenResult;
use crate::plugins::BuiltinPlugin;
use quote::quote;
use syn::{File, Type};
use crate::plugins::godot::tmp::types::CairoToRust;

pub(crate) mod tmp;

fn str_to_ident(str_in: &str) -> Ident {
    Ident::new(str_in, Span::call_site())
}

fn str_to_type(str_in: &str) -> Type {
    syn::parse_str(str_in).unwrap_or_else(|_| panic!("Can't convert {} to syn::Type", str_in))
}


#[derive(Debug)]
pub struct GodotPlugin {
    generated_time: DateTime<Utc>,
}

impl GodotPlugin {
    pub fn new() -> Self {
        Self {
            generated_time: Utc::now()
        }
    }

    fn get_header(&self) -> String {
        // NOTE: Procedural macros cannot insert comments.
        //  As this is meant to be read by a user, we hard-code it in the output.
        format!(
            "// Generated by dojo-bindgen on {}. Do not modify this file manually.\n",
            self.generated_time.to_rfc2822()
        )
    }

    fn get_imports(&self) -> TokenStream {
        quote! {
            use godot::prelude::*;
            use cainome::cairo_serde::ContractAddress;
            use dojo_types::schema::Struct as DojoStruct;
        }
    }

    fn handle_struct(&self, composite: &Composite) -> TokenStream {
        // TODO: Migreate to something else later
        let declaration = CairoStruct::expand_decl(composite,
                                                   &["Clone".to_string(), "Debug".to_string()]);

        let implementation = CairoStruct::expand_impl(composite);

        quote! {
            #declaration

            #implementation
        }
    }

    fn handle_enum(&self, composite: &Composite) -> TokenStream {
        // TODO: Migreate to something else later
        let declaration = CairoEnum::expand_decl(composite,
                                                 &["Clone".to_string(), "Debug".to_string()]);

        let implementation = CairoEnum::expand_impl(composite);

        quote! {
            #declaration

            #implementation
        }
    }

    fn handle_function(&self, function: &Function) -> TokenStream {
        CairoFunction::expand(function, true, ExecutionVersion::V1)
    }

    fn handle_interface(&self, _name: &str, _functions: Vec<Token>) -> TokenStream {
        // TODO
        quote!()
    }

    fn handle_model(&self, _name: &str, model: &DojoModel) -> TokenStream {
        let imports = self.get_imports();

        let struct_declarations: Vec<TokenStream> = model.tokens.structs.iter()
            .map(|e| e.to_composite().expect("A struct is not a composite?"))
            .map(|composite| self.handle_struct(composite))
            .collect();

        let enum_declarations: Vec<TokenStream> = model.tokens.enums.iter()
            .map(|e| e.to_composite().expect("An enum is not a composite?"))
            .map(|composite| self.handle_enum(composite))
            .collect();

        let function_declarations: Vec<TokenStream> = model.tokens.functions.iter()
            .map(|e| e.to_function().expect("Function is not a function?"))
            .map(|func| self.handle_function(func))
            .collect();


        quote! {
            #imports

            #( #struct_declarations )*

            #( #enum_declarations )*

            #( #function_declarations )*
        }
    }

    fn get_file(&self, stream: TokenStream) -> Vec<u8> {
        // TODO: This is not optimized, at all. We clone & resize vectors, but welp
        // TODO: Remove the unwrap

        let value: File = syn::parse2(stream).unwrap();
        let parsed_contents = prettyplease::unparse(&value);

        format!("{}{}", self.get_header(), parsed_contents)
            .into_bytes()
    }
}


#[async_trait]
impl BuiltinPlugin for GodotPlugin {
    async fn generate_code(&self, data: &DojoData) -> BindgenResult<HashMap<PathBuf, Vec<u8>>> {
        let mut imports = vec!();

        let mut files: HashMap<PathBuf, Vec<u8>> = HashMap::new();

        for (name, model) in &data.models {
            let name = name.split('-').last().unwrap().to_lowercase();
            imports.push(Ident::new(&*name, Span::call_site()));

            println!("Adding file {name}...");

            let path = Path::new(&format!("{}.rs", name)).to_owned();
            files.insert(path, self.get_file(self.handle_model(&*name, model)));

            println!("Added file! {name}");
        }

        let lib_contents = quote! {
            #( pub mod #imports; )*
        };

        println!("Finishing!!! {}", lib_contents);

        files.insert(Path::new("lib.rs").to_owned(), self.get_file(lib_contents));

        // TODO: Contracts?

        Ok(files)
    }
}